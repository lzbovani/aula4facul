# -*- coding: utf-8 -*-
"""aula4_facul.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w8wD4ha9z5eVWL4PrfAbzIGKK_-Ou1tM
"""

import numpy as np
import scipy.stats as stats
import pandas as pd




#dados exemplo
dados = [10, 20, 30, 40, 50, 100, 150, 200, 300, 500]

#media
media = np.mean(dados)

#media ponderada
pesos = [1, 1, 1, 1, 1, 2, 2, 2, 3, 3]
media_ponderada = np.average(dados, weights=pesos)

#mediana
mediana = np.median(dados)

#mediana ponderada
def mediana_ponderada(dados, pesos):
    dados_ordenados, pesos_ordenados = zip(*sorted(zip(dados, pesos)))
    acumulado_pesos = np.cumsum(pesos)
    return dados_ordenados[np.searchsorted(acumulado_pesos, acumulado_pesos[-1] / 2)]

mediana_ponderada = mediana_ponderada(dados, pesos)

#media aparada
media_aparada = stats.trim_mean(dados, proportiontocut = 0.1)

#iqr
p25, p75 = np.percentile(dados, [25, 75])

iqr = p75 - p25

#detecção de outliers com iqr
limite_inferior = p25 - 1.5 * iqr
limite_superior = p75 + 1.5 * iqr
outliers = [x for x in dados if x < limite_inferior or x > limite_superior]

#variancia
variancia = np.var(dados) #nao tenho uma unidade "boa"; unidade vai ser quadratica

#desvio padrão amostral
desvio_padrao_amostral = np.std(dados, ddof=1) #ddof=1 -> amostral

#desvio padrão populacional
desvio_padrao_populacional = np.std(dados, ddof=0) #ddof = 0 -> populacional

#amplitude
amplitude = np.max(dados) - np.min(dados)

#estaticas ordinais moda
moda = stats.mode(dados, keepdims=True).mode[0]

#estaticas ordinais quartis
quartis = np.percentile(dados, [25, 50, 75])

#estaticas ordinais percentis
percentis = np.percentile(dados, 90)

#desvio absoluto
mad = np.mean(np.abs(dados - np.mean(dados)))

estaticas ={
    "media": media,
    "media_ponderada": media_ponderada,
    "mediana": mediana,
    "mediana_ponderada": mediana_ponderada,
    "media_aparada": media_aparada,
    "variancia": variancia,
    "desvio_padrao_amostral": desvio_padrao_amostral,
    "desvio_padrao_populacional": desvio_padrao_populacional,
    "amplitude": amplitude,
    "moda": moda,
    "quartis": quartis,
    "percentis": percentis,
    "mad": mad

}
import pandas as pd

df_estat = pd.DataFrame.from_dict(estaticas, orient='index', columns=['Valor'])
display(df_estat)

"""#Exercicio

Carregue o dataset employees.csv em um DataFrame do Pandas.

Selecione apenas os funcionários do departamento de TI.

Encontre a média dos salários dos funcionários.

Filtre os funcionários que foram admitidos depois de 2019.

Crie uma nova coluna chamada "Tempo_Empresa", que representa o tempo (em anos) que o funcionário está na empresa.

Qual é o funcionário mais novo e o mais velho?

Qual é o cargo com o maior salário médio?

Agrupe os funcionários por departamento e encontre a média de salário em cada um.

Ordene os funcionários pelo tempo de empresa em ordem decrescente.

Calcule e indique a quantidade de outliers existentes em cada uma das colunas do dataset.
"""

import pandas as pd

# Carregar o dataset
df = pd.read_csv('/content/employees (1).csv')  # ajuste o caminho se necessário

# Extrair ano da admissão como inteiro
df['Ano_Admissao'] = df['Data_Admissão'].str[:4].astype(int)

# Calcular tempo de empresa com base no ano (supondo ano atual = 2025)
df['Tempo_Empresa'] = 2025 - df['Ano_Admissao']

# 1. Funcionários do departamento de TI
ti_employees = df[df['Departamento'] == 'TI']

# 2. Média dos salários
media_salarios = df['Salário'].mean()

# 3. Admitidos após 2019
admitidos_depois_2019 = df[df['Ano_Admissao'] > 2019]

# 4. Funcionário mais novo e mais velho
mais_novo = df.loc[df['Idade'].idxmin()]
mais_velho = df.loc[df['Idade'].idxmax()]

# 5. Cargo com maior salário médio
cargo_mais_salario = df.groupby('Cargo')['Salário'].mean().idxmax()
salario_medio_mais_alto = df.groupby('Cargo')['Salário'].mean().max()

# 6. Média salarial por departamento
media_por_departamento = df.groupby('Departamento')['Salário'].mean()

# 7. Funcionários ordenados por tempo de empresa
ordenados_tempo = df.sort_values(by='Tempo_Empresa', ascending=False)

# 8. Outliers por coluna numérica
outliers_info = {}
for col in df.select_dtypes(include=['int64', 'float64']).columns:
    q1 = df[col].quantile(0.25)
    q3 = df[col].quantile(0.75)
    iqr = q3 - q1
    outliers = df[(df[col] < (q1 - 1.5 * iqr)) | (df[col] > (q3 + 1.5 * iqr))]
    outliers_info[col] = len(outliers)

# Resultados organizados
print(" Funcionários do departamento de TI:")
print(ti_employees[['Nome', 'Departamento', 'Cargo']])

print(f"\n Média dos salários: R$ {media_salarios:.2f}")

print("\n Funcionários admitidos após 2019:")
print(admitidos_depois_2019[['Nome', 'Data_Admissão']])

print(f"\n Funcionário mais novo: {mais_novo['Nome']} ({mais_novo['Idade']} anos)")
print(f" Funcionário mais velho: {mais_velho['Nome']} ({mais_velho['Idade']} anos)")

print(f"\n Cargo com maior salário médio: {cargo_mais_salario} (R$ {salario_medio_mais_alto:.2f})")

print("\n Média salarial por departamento:")
print(media_por_departamento)

print("\n Funcionários ordenados por tempo de empresa:")
print(ordenados_tempo[['Nome', 'Tempo_Empresa']])

print("\n Quantidade de outliers por coluna:")
for coluna, qtd in outliers_info.items():
    print(f" - {coluna}: {qtd}")